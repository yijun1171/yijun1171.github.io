<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="coding | java | life" />



  <meta name="keywords" content="Keep hungry. Keep foolish" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="coding | java | life">
<meta property="og:type" content="website">
<meta property="og:title" content="Eden">
<meta property="og:url" content="http://yijun1171.github.io/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:description" content="coding | java | life">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eden">
<meta name="twitter:description" content="coding | java | life">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Eden </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Eden</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            歸檔
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/09/实习总结/" itemprop="url">
                实习总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-09-09T17:38:49+08:00" content="2015-09-09">
            2015-09-09
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="阿里实习总结">阿里实习总结</h2><p>5.14-8.31，在阿里百川&amp;TAE实习104天。</p>
<h3 id="感受">感受</h3><p>阿里的工作环境和员工待遇真的挺好，起码作为实习生在杭州可以生活的很舒服。<br>关于 <strong>加班</strong>，绝大部分的部门都是在加班的。在我看来，很多人都是白天不停的开会，评审，好多工作都只能晚上加班来安安静静的做。<br>关于 <strong>HR</strong>，就我接触到的HR和HRG来说，并没有网上黑的那么严重- -。我想毕竟公司大了，什么样的人都有，反正我在实习生群里没有看到多少吐槽HR和HRG的。<br>关于 <strong>同事</strong>，师兄师姐人都很nice，都是有问必答。印象深刻的是组里的师兄开玩笑的尺度都是没有下限的- -，但是团队氛围还是超级好，起码在部门以及boss的压力下在尽大家所能在认认真真做东西。<br>关于 <strong>部门</strong>，大公司，决定你的工作环境，团队氛围，成长空间的，都取决与你所在的部门，当然，包括老板。TAE是集团百川业务的底层技术平台，老板的压力很大，项目推进和迭代的速度很快，快到让我觉得有些虚浮，好像产品前进的脚步走得并不那么扎实。<br>关于 <strong>产品</strong>，虽然说老板有老板的KPI，员工有员工的KPI，大家压力都很大，但是我总觉得对产品细节和体验的雕琢不够，也就导致了自然引流过来的用户很难留住和转化。其实核心竞争力还是有的，但是让人用的就是不爽!这就是问题啊。</p>
<p>阿里是个大公司，很普通的大公司，没那么好，也没那么糟。</p>
<h3 id="收获">收获</h3><h4 id="项目">项目</h4><p>跟完一个完整的项目，是做内部监控和可视化展现(展现做的很low，前端水平有限，需要着重锻炼)。监控系统的数据来源都是其他系统，例如日志架构的某个节点，请求链路中的某个集群等等，都是分布式的环境。写代码的时候就要考虑到网络环境的因素(不是所有的通信都通过RPC，还有直接用HTTP交互数据的)，要保证网络抖动和不稳定时，程序的健壮性。<br>另一点就是合理和认真的处理异常。有一部分异常甚至成为了监控的业务逻辑，比如说，对某一个域名的请求超时，抛出超时异常，监控要能够判断出是读超时，还是连接超时，并合理报警。没有合理的异常体系设计和认真处理，是会漏掉很多case的。<br>对原有代码进行了部分重构，逐渐学会在设计时考虑程序的可扩展性。<strong>对修改关闭对扩展开放</strong>。</p>
<h4 id="通用技能">通用技能</h4><ol>
<li>学了一些Linux环境的基本运维技能</li>
<li>深入理解了Linux的IO栈，顺带复习了一下段页式虚存管理</li>
<li>排查线上问题的通用方法</li>
</ol>
<h4 id="长见识">长见识</h4><p>团队每周的技术分享还是很赞的，而且并不是每个团队都有这样的机会。<br>听了不少云产品的设计和实现，看了自己部门一些系统的架构设计。<br>从一开始带着星星眼去听，到后来带着问题和思考去听。为什么这么设计，难点在哪里，收获也是不少。</p>
<h4 id="吐槽">吐槽</h4><p>如果不做好配置管理和环境隔离，对开发简直是灾难！大公司都会有好几套代码环境，例如日常开发环境，测试环境，集成环境，线上环境。<br>我负责的监控系统会依赖很多的外部系统，大部分是采集监控数据的源点。然而在日常开发环境下，某些外部系统并没有部署，也就是说整个监控系统在日常下不能启动，我也就不能在开发时拿到像样的外部数据进行足够的单元测试，更别说debug了……<br>真实的数据只能到集成环境上面去拿，搞得我在集成环境里测试和修改，开发效率极低，而且很不爽。</p>
<p>项目管理实在是不规范，我吓了一跳。部门内部的JDK版本都不统一，没有统一的Coding Style，文档匮乏，槽点实在太多……</p>
<p>当然我能想象，在大量业务压力和时间逼迫下，工程师写下的每一行救火代码。但是好的代码习惯还是要保持的，毕竟对自己对他人都有好处。多谢师兄在如此不堪的大环境下，对我的严格要求。</p>
<h4 id="思考">思考</h4><ol>
<li>遇事要主动，尤其是需要其他人配合的时候。可能刚实习的时候，还是把自己定位为无关紧要的实习生，不太好意思找其他同事配合和援助。后来慢慢才认识到，工作上的事情一定要主动，主动，主动！重要的事情说3遍。尤其是一个人搞不定的时候。</li>
<li>要把自己融入团队，首先要把自己的定位放在团队里。我是团队的一员，才会更多的从团队的角度去考虑，去做一些有益与团队和产品的事。</li>
<li>遇到问题的第一反应是吐槽，然后必须是想办法解决它！干掉它！消灭它！不然公司给你钱是干嘛使得！其实蛮遗憾没去使劲解决项目的配置管理的问题。这就是教训吧……</li>
<li>以后要保持敬畏，对线上保持敬畏，对那些看起来难以掌控的满身槽点的项目保持敬畏(很有可能是你能力不够才没法让他变成看起来舒服的样子)</li>
</ol>
<h3 id="遗憾">遗憾</h3><ol>
<li>代码还是写得太少，实现很难说做到优雅</li>
<li>在阿里呆的3个月，很少和其他学校的优秀实习生交流，没有通过他们的成长和学习经验，来激励自己</li>
<li>和主管还是师兄私下沟通和聊天太少(但是他们每天都忙成啥了……)，聊行业聊技术聊选择，以后要点上科学扯淡这个技能！</li>
</ol>
<h3 id="打算">打算</h3><ol>
<li>先努力找个满意的工作</li>
<li>工作之余多写代码，多造轮子，尽量造业界新的技术的轮子</li>
<li>英语啊！u little bastard！</li>
<li>多接触牛人，闲来吹水，认真时请教</li>
</ol>
<h3 id="关于缩招">关于缩招</h3><ol>
<li>就公司这个做法，可能不是那么厚道，但是从法律和公司利益角度，它确实是合理的，求新求变就意味着要割肉，割肉当然从最不痛的开始割，谁让你是实习生。</li>
<li>就我个人而言，可能是我学艺不精，没能成为那些公司舍不得割的部分。起码我和公司两不相欠，我学到和收获了很多，也给公司干了不少活。</li>
</ol>
<p>拥抱变化，等NB了，回去甩它一脸。恩。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/05/11/ATF-感悟/" itemprop="url">
                ATF-感悟
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-05-11T21:24:51+08:00" content="2015-05-11">
            2015-05-11
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h1 id="阿里巴巴技术论坛(ATF)体验有感">阿里巴巴技术论坛(ATF)体验有感</h1>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/05/11/ATF-感悟/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/05/09/ali-intern-linux-TCP/" itemprop="url">
                ali-intern-linux&TCP
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-05-09T16:46:10+08:00" content="2015-05-09">
            2015-05-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/linux-TCP/" itemprop="url" rel="index">
                  <span itemprop="name">linux TCP</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="linux相关">linux相关</h1><h2 id="磁盘&amp;文件系统">磁盘&amp;文件系统</h2><h3 id="文件系统">文件系统</h3><p>虚拟文件系统(Virtual File System)为上层提供了一个<strong>统一的接口</strong>,不同的物理设备和文件系统类型对上层来说是透明的.对下层,新的物理设备和文件系统可以直接接入linux,而不必重写或者重新编译程序.<br><img src="http://yijun1171.github.io/img/VFS.gif" alt="VFS"><br>尽管内核是c语言编写的,VFS还是用<strong>面向对象</strong>的思想来实现的.虚拟文件系统中有四个主要对象(模型),他们可以用来描述所有任何一个系统中的特征和行为.它们用c语言的struct实现,struct中包含了<strong>数据</strong>和<strong>函数指针</strong>(内核调用他们来操纵数据).</p>
<ol>
<li>超级块(super block),表示一个已挂载的文件系统,一般存储在磁盘的特定扇区中.</li>
<li>索引节点(inode),表示一个文件(包括目录,物理设备,普通的文件)的所有元信息.这些信息保存在磁盘中,当访问一个文件时从磁盘读取数据(从元数据区)然后在内存中创建inode(struct).inode的操作<strong>由文件所在的文件系统实现</strong>.</li>
<li>目录项(dentry),表示一个目录项,它是一个路径的组成部分,提高了通过路径进行文件查找的效率(主要是通过<strong>缓存</strong>避免每次查找都要通过系统调用).它并不对应磁盘中的数据,当用字符串表示一个路径的时候它才会被创建(不需要写回).</li>
<li>文件对象(file),表示一个进程打开的文件</li>
</ol>
<h4 id="访问文件的过程">访问文件的过程</h4><p>file-&gt;dentry-&gt;inode-&gt;data<br>其中dentry和inode的查找都会使用缓存,而inode中保存的文件数据的块号,并且使用<strong>多级索引</strong>.</p>
<p>注意:目录项(dentry)不是目录,目录(directory)是文件(file)的一种形式</p>
<h3 id="块设备">块设备</h3><p>块设备是指linux系统中支持<strong>随机访问</strong>固定大小数据块的设备.<br>扇区(sector)是块设备的最小寻址单位,通常是512字节.而软件层面的最小寻址单位则是块(block),块大小通常是512B,1KB,4KB.<br>2.6版本以后,每个block IO request用一个bio structure来表示.每个请求会包括不同位置的块(在不同的页中),bio用一个bio_vec链表来记录请求中所有块的位置,链表节点&lt; page,offset,len &gt;,记录了块在物理页中的具体位置.(其中有一个小细节,bi_idx指向了当前节点的位置,有了这个特性可以跟踪IO请求的完成情况,甚至RAID的IO也是通过它来实现的:) </p>
<p>inode table还有block和其他一些元数据在分区格式化的时候创建和划分.</p>
<h3 id="挂载">挂载</h3><p>将文件系统与目录树结合,挂载点是该文件系统的入口.</p>
<h2 id="常用命令">常用命令</h2><p>用法记录在cheatsheet中,持续保持更新</p>
<h2 id="shell">shell</h2><p>参考一本评价较高的Bash手册,写了一些测试代码在这里:<a href="https://github.com/yijun1171/shell-learning-notes" target="_blank" rel="external">shell-learning-notes</a></p>
<h1 id="TCP">TCP</h1><h3 id="状态机">状态机</h3><p><img src="http://yijun1171.github.io/img/tcpfsm.png" alt="state-machine"><br>图片来源:<a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">CollShell</a></p>
<h3 id="建立连接">建立连接</h3><p>TCP建立连接的过程一般经过三步</p>
<ol>
<li>client发送SYN</li>
<li>server返回SYN+ACK</li>
<li>client返回ACK<br>我们成为<strong>三次握手</strong></li>
</ol>
<p>初始序号(ISN)是随时间变化而变化的,这样保证连接重连时,上一个连接在网络中延迟的包不会被错误地解释.</p>
<p>双方同时打开,可能会出现交换了4个报文的情况(不多见)</p>
<h3 id="关闭连接">关闭连接</h3><p>TCP关闭连接一般分为4步</p>
<ol>
<li>A发送FIN</li>
<li>B发送ACK</li>
<li>B发送FIN</li>
<li>A发送ACK</li>
</ol>
<p>从状态转换的角度来说</p>
<ol>
<li>A接到上层应用的关闭指令,发送FIN后,转换到<em>FIN_WAIT1</em>状态</li>
<li>B收到FIN,发送ACK后,转换到<em>CLOSE_WAIT</em>状态.此时连接处于<strong>半关闭</strong>.B仍然可以发送数据,而A通过发送FIN表示自己不再发送数据.</li>
<li>B接到上层应用的关闭指令后,发送FIN,状态转换到<em>LAST_ACK</em>.</li>
<li>A收到FIN后,发送最后一个ACK,状态转换到<em>TIME_WAIT</em><br>A在收到最后一个ACK后真正关闭连接<br>B在等待2MSL的时间(并且没有收到A重发的FIN)后真正关闭连接</li>
</ol>
<h4 id="Time_wait">Time_wait</h4><p>首先发起关闭的那一方,在发送了最后一个ACK之后,会等待2MSL的时间,这样做的原因:</p>
<ol>
<li>保证最后那个ACK一定被对端接收到.如果该ACK丢失,对端会在2MSL时间内重发FIN,保证正常关闭.这样一来一回,时间正好2MSL</li>
<li>在等待这2MSL时间的过程中,网络中被缓存或者延迟的数据包也会失效.这样保证下一个连接(socket的四元组完全一样)建立的时候,那些数据包不会产生异常的影响.</li>
</ol>
<h3 id="复位报文段">复位报文段</h3><p>TCP的标志位中有一个<strong>复位</strong>(RST).它有以下作用:</p>
<ol>
<li>到不存在的端口的连接请求,对端会返回一个RST置1的报文,表示端口不可达.<br><img src="http://yijun1171.github.io/img/tcp-connRefuse.png" alt=""></li>
<li>检测半打开的连接.在没有设置keepalive的情况下,如果server异常断开,client不会察觉,当server恢复时,client向server发送消息,server会返回一个RST,表示之前连接的所有信息已经丢失</li>
</ol>
<h3 id="超时处理">超时处理</h3><h4 id="连接建立超时">连接建立超时</h4><p>目的端处于不正常状态,无法响应SYN报文请求(一般是目的端<strong>连接队列</strong>中的连接数超过了<strong>backlog</strong>).请求端间隔一定时间后重发SYN试图重建连接.重传间隔大约是2^n.<br>这是测试时设置大量tcp请求连接,而服务器端吞吐量很小时,无法即时响应SYN,客户端只能持续重传.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数10设置了超时时间</span></span><br><span class="line">socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">9999</span>), <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>当连接建立过程超过如上设置的超时时间,java会抛出SocketTimeoutException异常<br><img src="http://yijun1171.github.io/img/tcp-connTimeout.png" alt="conn-timeout"><br>TCP有一个默认的最大重试等待间隔,大约是75s,超过这个间隔扔无法建立连接,TCP协议本身会停止尝试,向上层说明connection timeout</p>
<h4 id="读超时">读超时</h4><p>TCP的REVQ没有可读数据时,read操作会阻塞,直到有数据可读或者超时.超时时间通过<code>setSoTimeout()</code>方法设置.当抛出超时异常时,<strong>本socket仍然有效</strong>,只是提示本次读操作超时异常.</p>
<h3 id="Java中socket常用参数">Java中socket常用参数</h3><ol>
<li>SO_KEEPALIVE:保活机制,探测的时间间隔参数在内核中设定.该参数会影响所有socket的行为</li>
<li>SO_RCVBUF &amp; SO_SNDBUF:设置读写缓冲区大小,至少为MSS的4倍(用于3duplicate-ACK,保证快速重传)</li>
<li>SO_TIMEOUT:设置读超时的时间</li>
<li>SO_REUSEADDR:<ul>
<li>监听进程重启时,保证重新绑定之前的端口操作成功.</li>
<li>允许在同一个端口上启动同一个服务器的多个实例</li>
</ul>
</li>
</ol>
<p>参考资料:</p>
<ol>
<li><a href="http://book.douban.com/subject/5503292/" target="_blank" rel="external">linux内核设计和实现</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/" target="_blank" rel="external">Linux文件系统剖析</a></li>
<li><a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="external">Advanced Bash-Scripting Guide</a></li>
<li><a href="http://awk.readthedocs.org/en/latest/index.html" target="_blank" rel="external">AWK入门指南</a></li>
<li><a href="http://book.douban.com/subject/1088054/" target="_blank" rel="external">TCP/IP详解 卷1</a></li>
<li><a href="http://book.douban.com/subject/4859464/" target="_blank" rel="external">UNIX网络编程 卷1：套接字联网API</a></li>
<li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">CoolShell-TCP那点事儿</a></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/05/01/ali-intern-java基础整理/" itemprop="url">
                ali-intern-java基础整理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-05-01T14:49:10+08:00" content="2015-05-01">
            2015-05-01
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/java/" itemprop="url" rel="index">
                  <span itemprop="name">java</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="java基础">java基础</h1><h2 id="并发">并发</h2><h3 id="内存模型">内存模型</h3><p>根据jls中的定义</p>
<blockquote>
<p>内存模型描述了一个程序的执行过程是否合法.<br>JMM通过检查一个程序的执行链中的<strong>读操作</strong>和基于该读取操作引起的<strong>写操作</strong>是否满足指定的<strong>规则</strong>.</p>
</blockquote>
<p>内存模型只是描述了一个程序的行为.只要程序的执行结果可以被内存模型预测,也就是说满足内存模型中的规则,那么程序的指令级优化可以尽可能的减少冗余代码或者乱序执行.</p>
<ol>
<li>共享变量:实例字段,静态字段,数组的元素.不包括线程私有的局部变量和方法参数.</li>
<li>数据不一致:线程之间的共享变量存储在主存中,而线程对其进行操作和运算之前会在线程的<strong>本地内存</strong>保存变量的副本,所有的操作和运算是在这个副本上进行的.那么共享变量在多个线程中的副本就会出现不一致的现象.本地内存是JMM的一个<strong>抽象概念</strong>,它实际上涵盖Cache,寄存器,写缓冲区以及其他硬件.JMM就规定了保证线程之间数据一致的规则.</li>
<li>指令重排序:编译器优化时,可能会改变语句执行的顺序.处理器的并行指令技术可能会改变指令的执行顺序.因此导致程序在真正运行时的指令执行顺序有可能与源代码不一样,我们称之为重排序.但是为了保证程序正确执行,JMM会禁止<strong>特定</strong>的编译器重排和处理器重排.</li>
<li>数据依赖:JMM保证不管怎么重排序,程序的结果不能改变.因此存在数据依赖的操作不会被重排序</li>
<li>Happens-before:如果一个动作happens-before另一个动作,那么第一个操作的影响一定会被第二个操作观察到.这些规则保证了内存的可见性.<ul>
<li>程序次序</li>
<li>constructor-&gt;finalizer</li>
<li>If an action x synchronizes-with a following action y, then we also have hb(x, y).</li>
<li>happens-before具有传递性</li>
<li>同一个监视器锁的unlock-&gt;后面对同一个锁的lock操作</li>
<li>对volatile变量的写-&gt;对它的读</li>
<li>线程的start操作-&gt;所有线程中的操作</li>
<li>线程中的所有操作-&gt;join操作</li>
</ul>
</li>
</ol>
<p><strong>volatile</strong></p>
<ol>
<li>对所有线程立即可见,在所有线程中是一致的.但不是线程安全的.(对volatile变量的操作不一定是原子的).通过反汇编发现lock指令在IA32架构中会使其他cpu的Cache无效,同时本cpu的Cache写入内存.</li>
<li>禁止指令重排序优化.<br><strong>使用volatile变量,会从主存读取最新的值.对volatile变量赋值后会立即刷新到主存.</strong></li>
</ol>
<p><strong>锁</strong><br>锁的unlock-lock的happens-before规则保证线程A释放锁之前所有可见的共享变量,在线程B获取<strong>同一个锁</strong>之后,立即对线程B可见.<br><strong>释放锁会将线程本地内存中的共享变量刷新到主存.获取锁时会从主存读取共享变量.</strong></p>
<p><strong>final</strong></p>
<ol>
<li>在构造函数内对一个 final 域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.(非final域在构造函数中被赋值之前,被构造的对象的引用可能就已经被赋值给一个引用变量了.<strong>DCL失效有可能是这个原因造成的</strong>)</li>
<li>初次读一个包含 final 域的对象的引用,与随后初次读这个 final 域,这两个操作之间不能重排序(保证对象的引用不是null时,final域一定已经被初始化了) </li>
</ol>
<h3 id="线程">线程</h3><h4 id="线程实现">线程实现</h4><ol>
<li>内核线程实现:一对一模型.需要系统调用,在用户态和内核态中来回切换,代价高,并且直接消耗内核资源,支持的线程数量非常有限</li>
<li>用户线程实现:一对多模型.基于用户态的线程库,内核无法感知线程的生命周期,它完全在用户态中进行.实现复杂.</li>
<li>混合实现:多对多模型.用户线程的系统调用通过轻量级线程完成.</li>
<li>java线程的实现:取决于平台,windows和Linux提供一对一的线程模型</li>
</ol>
<h4 id="线程调度">线程调度</h4><p>java线程采用抢占式调度,由系统来分配执行时间.可以通过设置优先级控制线程被选择执行的概率.但是不能完全准确的判断每个线程谁一定先执行.因为java中的线程优先级和操作系统的线程优先级并不是一一对应的.<br>Thread类中定义了5中状态:New Runnable Blocked Waiting Timed_waiting<br>Blocked:在等待获取一个排他锁<br>Waiting:无限期等待,只能被显式唤醒.可能由以下方法导致:无参调用 Object.wait() Thread.join()<br>Timed_Waiting:有限等待,自动被系统唤醒.Thread.sleep()  有参调用Object.wait() Thread.join()</p>
<p>常用方法:</p>
<ol>
<li>yeild方法,提示cpu该线程让出执行权,具体决定取决于cpu,不保证立即发生调度</li>
<li>sleep方法,进入有限等待状态,不会释放持有的监视器锁</li>
<li>start()方法,在Thread对象创建之后被调用一次,否则会抛出异常</li>
<li>run()方法,只有Thread用Runnable对象创建时,调用该方法会执行Runnable对象的run方法(并没有创建新的线程!),否则不做任何操作,直接返回.</li>
</ol>
<h4 id="线程同步">线程同步</h4><p>常用的多线程同步机制</p>
<ul>
<li>volatile 变量：轻量级多线程同步机制，不会引起上下文切换和线程调度。仅提供内存可见性保证，不提供原子性。</li>
<li>CAS 原子指令：轻量级多线程同步机制，不会引起上下文切换和线程调度。它同时提供内存可见性和原子化更新保证。</li>
<li>内部锁和显式锁：重量级多线程同步机制，可能会引起上下文切换和线程调度，它同时提供内存可见性和原子性。</li>
</ul>
<p><strong>synchronized(内部锁)</strong><br>synchronized实现主要依靠<strong>监视器</strong>,每个对象有一个监视器,线程可以lock和unlock.任何时候只能有一个线程持有某个特定对象的监视器,之后任何线程对该监视器的lock尝试都会导致他们陷入阻塞状态,直到那个监视器unlock.监视器锁可重入,unlock次数要等于lock次数,该监视器锁才会被真正释放<br>synchronized声明 先计算引用的对象-&gt;尝试获取监视器锁-&gt;执行同步代码块-&gt;执行结束后自动释放监视器锁<br>synchronized方法 实例方法获取实例的锁,静态方法获取相应Class对象的锁,方法执行结束后自动释放监视器锁</p>
<p><strong>ReentrantLock(显式锁)</strong><br>使用类似synchronized,但提供一下高级功能:</p>
<ol>
<li>等待可中断</li>
<li>公平锁与非公平锁:是否按申请顺序依次获得锁</li>
<li>绑定多个Condition对象</li>
</ol>
<p><strong>非阻塞同步</strong><br>CAS 存在ABA问题,但一般不会影响并发正确性</p>
<p><strong>ThreadLocal</strong><br>将变量的使用范围限制在本线程中<br>ThreadLocal实例操控Thread实例中的LocalMap,将变量限制在线程中.每个Thread实例都有一个LocalMap,ThreadLocal为key,持有的变量为value.</p>
<p><strong>等待集合(wait set)</strong><br>每个对象会关联一个等待集合(wait set),集合元素是在该对象的监视器上等待的线程.<br>通过Object.wait Object.notify Object.notifyAll 来操纵等待集合,同时它还受当前线程的中断状态和Thread类的中断方法影响.</p>
<p><strong>Wait</strong><br>线程t调用对象m的wait(),并且未unlock的次数为n,调用之后,一下过程按序执行</p>
<ol>
<li>t加入到m的等待集合里,并且执行n次unlock(释放掉吃有的m的锁)</li>
<li>直到t被移出等待集合之前,t中的指令不再执行,移出等待集合的触发动作是:<br>  a.在m上调用notify(),并且t被选中<br> b.在m上调用notiyfAll()<br> c.如果是timed wait,等待时间到了之后,t会被内部动作移出等待队列<br> d.中断t</li>
<li>执行n次lock(重新获得m的监视器锁)</li>
<li>如果在步骤2中移出等待集合的原因是中断,t的中断状态置为false,并且wait方法抛出InterruptionException</li>
</ol>
<p><strong>Notification</strong><br>通知动作因notify和notifyAll方法的调用而发生<br>线程t在对象m上执行以上两种方法之一时,并且未unlock的次数为n,以下动作依次发生:</p>
<ol>
<li>如果n是零,抛IllegalMonitorStateException(必须持有监视器锁)</li>
<li>如果n大于零,并且执行的是notify,从m的等待集合中选择一个线程.同时不能保证哪一个线程被唤醒,被唤醒的线程在t执行n次unlock之后,重新获得m的锁</li>
<li>如果n大于零,并且执行的是notifyAll,所有线程被移出等待集合,但是只有一个线程能够竞争获取到m的监视器锁.</li>
</ol>
<h4 id="中断">中断</h4><p>调用Thread.interrupt会发生中断,会将被调线程的中断状态置为true</p>
<blockquote>
<p>如果该线程在object的wait方法上阻塞,或者在Thread的join,sleep方法上阻塞,本线程的中断状态将被清除,并抛出InterruptionException<br>如果该线程阻塞在可中断的channel之上的IO操作,那么这个channel会关闭,该线程的中断状态会被设置,该线程会收到一个 ClosedByInterruptException<br>如果该线程正阻塞在selector上,那么中断状态会被设置,并且从select方法中返回,返回值是非零值,类似selector的wakeup方法被调用<br>如果不是以上情况,那么只有线程的中断状态被设置</p>
</blockquote>
<p><strong>总而言之,java的中断机制本质上是一种线程间的协作机制,它并不保证一定能终止线程的执行.个人理解,中断的最合适的应用场景是用来处理取消请求.</strong><br>interrupt方法会将线程的中断状态设置为true.某些方法在调用过程中会检查当前线程的中断状态,并抛出异常,通知线程它被中断了.这样的方法叫可中断方法.线程的执行过程中检测到这样的中断引起的异常后,根据需要进行对应的处理.在执行不可中断方法的时候,如果外界调用了该线程的interrupt,该线程也不会有感知,只是中断状态被设置为true而已,所以并不会停止方法的执行</p>
<p>isInterrupted方法只检查中断不状态,没有任何影响<br>interrupted静态方法会将中断状态清零</p>
<p><strong>处理中断</strong><br>既然是线程自己处理状态,那么就要在合适的时间去检查中断状态(检查中断需要轮训中断状态).合适的时间也取决于业务需求.在检测到中断请求后,有以下两个处理原则</p>
<ul>
<li>如果遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常，如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。</li>
<li>若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态。如果是检测并清除了中断状态，亦是如此。</li>
</ul>
<p><strong>中断响应</strong><br>视情况而定, 可能是终止线程,回滚执行过的任务,执行下一个任务等等</p>
<p>sleep和yield没有同步的语义,也就是说,执行前后不会更新缓存中的共享变量.<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">while</span><span class="params">(!this.done)</span></span> <span class="comment">// done is volatile boolean</span></span><br><span class="line">    Thread.<span class="function"><span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上代码,即使其他线程更新了done的状态,仍然有可能死循环</p>
<h4 id="线程池">线程池</h4><p><strong>Executor接口</strong><br>线程池初始化时,构造函数中的参数代表了任务的执行策略.在什么线程中执行,按什么顺序执行,有多少任务能并发执行,队列中有多少个任务在等待,过载的话选择哪个任务拒绝,怎么通知应用程序有任务被拒绝.</p>
<p><strong>Executors提供的配置好的线程池</strong></p>
<ol>
<li>newFixedThreadPool:core和max线程数一样,所以当线程数增长到固定数之后就不再新增线程</li>
<li>newCachedThreadPool:core=0,max=Integer.MAX_VALUE.使用吞吐率很高的SynchronousQueue,每提交一个任务就新增一个线程去处理,线程执行完任务后如果还在生存期之内的话可以重用</li>
<li>newSingleThreadPool:core=max=1,使用无界队列,单线程执行任务,执行顺序和提交顺序相同</li>
<li>newScheduledThreadPool:固定长度线程池,以延迟或定时的方式执行任务<br>任务队列保存在BlockingQueue中,有三种可选:无界队列,有界队列,同步移交.</li>
</ol>
<p><strong>新任务的执行流程</strong></p>
<p><strong>合理配置线程池</strong></p>
<ol>
<li>cpu密集型任务使用尽可能少的线程:N+1</li>
<li>IO密集型任务使用尽可能多的线程:2*N</li>
<li>优先级不同的任务使用PriorityBlockingQueue</li>
</ol>
<p><strong>线程饥饿死锁</strong><br>只要线程池中的任务需要无限期的等待一些必须由池中其他任务才能提供的资源或者条件,那么除非线程池足够大,否则将发生线程饥饿死锁.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Callable&lt;String&gt;</span>&#123;</span><br><span class="line">        Future&lt;String&gt; header, footer;</span><br><span class="line">        header = exec.submit(<span class="keyword">new</span> LoadTask(<span class="string">"head"</span>)); <span class="comment">//exce是单线程的线程池</span></span><br><span class="line">        footer = exec.submit(<span class="keyword">new</span> LoadTask(<span class="string">"foot"</span>));</span><br><span class="line">        String page = body();</span><br><span class="line">        <span class="keyword">return</span> header.get() + page + footer.get(); <span class="comment">//等待任务队列中的任务,将会发生死锁</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用无界队列固定大小的线程池,在任务到达速率超过线程池处理速率的情况下,仍然可能会耗尽资源.<br>更稳妥的策略是使用有界队列</p>
<ol>
<li>线程池较小而队列较大,可以降低CPU的使用率和上下文切换频率,但是限制了吞吐量</li>
<li>对于大的线程池,配合<strong>SynchronousQueue</strong>可以避免任务排队.基于该队列的性质,任务可以直接交给工作线程.如果线程池大小已经到达最大值,而且没有空闲线程的话,根据<strong>饱和策略</strong>,这个任务将被拒绝.</li>
<li>针对任务之间存在依赖关系,可能发生线程饥饿死锁的情况,应该使用无界的线程池,例如newCachedThreadPool</li>
</ol>
<p><strong>饱和策略</strong></p>
<ol>
<li>Abort:默认策略,抛出RejectedException,调用者自己处理拒绝任务</li>
<li>Discard:抛弃提交被拒绝的任务</li>
<li>Discard-Oldest:抛弃队列中下一个将被执行的任务,不要和优先级队列一起使用</li>
<li>Caller-Runs:不抛弃任务也不抛异常,将任务回退给调用者.在调用execute的线程中执行该任务,因此主线程在一段时间内不能提交任何任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++);<span class="comment">//execute</span></span><br><span class="line">            System.out.println(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> CAPACITY = <span class="number">8</span>;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                                 <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(CAPACITY));</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        Thread.currentThread().setName(<span class="string">"main"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(),<span class="string">"Task-"</span> + i));</span><br><span class="line">             <span class="comment">//当任务队列满之后,实际的任务执行线程变成main</span></span><br><span class="line">            System.out.println(<span class="string">"submit task "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>生命周期管理</strong><br>ExecutorService<br>shutdown执行平缓关闭,不再接受新的任务,同时等待已经提交的任务执行完毕.<br>shutdownNow尝试取消所有运行中的任务,不再启动队列中没开始的任务.</p>
<p>Callable代表任务<br>Future表示任务的生命周期,可以通过它判断是否已经完成或者取消,以及获取任务的结果和取消任务<br>Future可以设置任务执行的超时时间,get(time,timeUnit),超时会抛出异常,捕获异常后取消任务即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    result = future.get(timeLeft, NANOSECOND);</span><br><span class="line">&#125; <span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span>(TimeoutException e)&#123;</span><br><span class="line">    future.cancle(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExecutorService的submit提交任务方法返回该任务的Future,用来监控任务的状态<br>invokeAll(List<callable>, long, time) 集中提交一组任务,返回一组结果,每个任务要么执行完毕要么被取消了</callable></p>
<h2 id="容器">容器</h2><p>常用容器类图</p>
<h3 id="常用容器">常用容器</h3><p>主要分为两大类</p>
<ol>
<li>Collection的子接口:List,Set,Queue<ul>
<li>List的实现类包括不同步的:ArrayList和LinkedList,分别基于数组和链表实现.同步的Vector和Stack</li>
<li>Set的实现类包括HashSet,LinkedHashSet,TreeSet.HashSet基于HashMap实现的,LinkedHashSet在哈希的存储结构上提供了控制迭代顺序的功能,利用辅助的双向链表来记录顺序.TreeSet基于TreeMap实现的</li>
<li>Queue的实现类包括LinkedList,PriorityQueue和大量的阻塞队列</li>
</ul>
</li>
<li>Map的实现类:HashMap, TreeMap,HashTable(同步的)<ul>
<li>HashMap,拉链法实现的哈希表,使用HashMap最重要的是作为键的类正确实现了hashCode方法和equals方法,并且不可变.</li>
<li>TreeMap,红黑树实现的K-V映射,保证了键有序</li>
</ul>
</li>
</ol>
<p>在使用有序容器时要正确实现Comparable接口<br>Collections和Arrays提供了常见的容器操作<br>阻塞队列的实现基本采用了RentrentLock和Condition,实现了生产者-消费者模型,同时还可以选择性保持线程公平</p>
<h3 id="并发容器(非阻塞)">并发容器(非阻塞)</h3><p><strong>并发容器大多采用了非阻塞算法进行同步,算法实现是基于处理器指令集提供的CAS指令,这是一种乐观锁形式的同步方式,并且锁的粒度非常小,这也就意味着实现的复杂性.</strong></p>
<p>基于非阻塞算法的容器:</p>
<ul>
<li>ConcurrentLinkedQueue:基于链接节点的无界线程安全队列</li>
<li>SynchronousQueue:没有容量的阻塞队列，它使用双重数据结构 来实现非阻塞算法</li>
<li>Exchanger:是一个能对元素进行配对和交换的交换器</li>
<li>ConcurrentSkipListMap:是一个可以根据 Key 进行排序的可伸缩的并发 Map</li>
</ul>
<h2 id="IO&amp;NIO">IO&amp;NIO</h2><h3 id="IO">IO</h3><p>IO相关的类大概可分为4种</p>
<ol>
<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li>
<li>基于字符操作的 I/O 接口：Writer 和 Reader</li>
<li>基于磁盘操作的 I/O 接口：File</li>
<li>基于网络操作的 I/O 接口：Socket</li>
</ol>
<h4 id="常见字节流">常见字节流</h4><p>ByteArrayInputStream:用内部字节数组保存字节流<br>FileInputStream:常用的文件读取字节流<br>SocketInputStream:<br>FilterInputStream:只是InputStream的一个包装类,主要的额外操作由它的子类提供<br>BufferedInputStream:一次性从流中读取多个字节保存到内部的缓冲<br>DataInputStream:可以读取基本java数据类型<br>ObjectInputStream:用于反序列化.序列化需要对象实现Serializable接口,static和transient修饰的属性不会被序列化.基本数据类型和对象引用都会被序列化<br>PipedInputStream:作用类似操作系统层面的管道,将输入直接写入设置好的输出管道流.多用于多线程之间的数据交换</p>
<p>输出流大致同上</p>
<h4 id="常见字符流&amp;字节字符转化接口">常见字符流&amp;字节字符转化接口</h4><p>常见字符流的包装类的类型和字节流很类似,只是将字节转码变成了字符<br>解码:inputStreamReader<br>编码:outputStreamWriter</p>
<h3 id="NIO">NIO</h3><p>Non-blocking IO</p>
<h4 id="Channel">Channel</h4><p>一个Channel代表了到一个实体的打开的连接,这个实体包括文件,socket,或者一个程序的组件.类比传统的IO,Channel更像是流,数据可以写入Channel,也可从Channel中读取.Channel的读写通过Buffer进行.支持阻塞和<strong>非阻塞</strong>两种工作模式</p>
<p>Channel还支持分散和聚集操作,即连续向多个Buffer读写数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Buffer header = Buffer.allocate(<span class="number">128</span>);</span><br><span class="line">Buffer body = Buffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">Buffer[] bufferArray = &#123;header, body&#125;;<span class="comment">//Buffer的读写顺序和数组的元素顺序一致</span></span><br><span class="line">channel.write(bufferArray);<span class="comment">//channel.read(bufferArray)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Channel之间传输数据</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure></p>
<p><strong>具体的实现类</strong></p>
<ol>
<li>FileChannel:用于文件读写,不能设置为非阻塞式,position方法支持随机读写.</li>
<li>DatagramChannel:用于UDP读写</li>
<li>SocketChannel:用于TCP客户端读写,支持阻塞和非阻塞两种工作模式</li>
<li>ServerSocketChannel:用于TCP服务器端</li>
</ol>
<h4 id="Buffer">Buffer</h4><p>Buffer是数据缓冲区,有读/写两种工作模式.使用时要正确的调整工作模式(flip方法),Buffer<strong>非线程安全</strong>,多线程共享Buffer操作时要进行同步</p>
<p><strong>三个关键属性</strong></p>
<ol>
<li>capacity:缓冲区固定大小</li>
<li>position:表示当前读写的位置.写模式下position从0增长到limit.读模式下从limit减小到0</li>
<li>limit:可读写的数据边界.写模式下等于capacity,读模式下被设置成flip操作之前position的位置,表示最后一个可读数据的位置.</li>
</ol>
<p><strong>常用操作</strong></p>
<ol>
<li>flip:切换工作模式</li>
<li>clear:将position置为0,将position置为capacity,表示Buffer清空(实际上数据并没有被清除)</li>
<li>compact:将未读的数据copy到Buffer开头的位置,将position置为最后一个未读数据的下一个位置,limit置为capacity,表示可以接着写入,而不覆盖未读的数据</li>
<li>rewind:将position置为0,表示可以再重新读取数据</li>
<li>mark和reset:标记一个位置,然后可以调用reset将position回溯到标记的位置</li>
</ol>
<p><strong>几个属性之间的关系</strong><br><em>0 &lt;=mark&lt;= position &lt;= limit &lt;= capacity</em></p>
<p><strong>数据读写</strong><br>支持基本数据类型和单字节读写</p>
<p><strong>分配和包装</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = Buffer.allocate(<span class="number">1024</span>);<span class="comment">//分配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">ByteBuffer buf = Buffer.wrap(array);<span class="comment">//将数组包装成buffer</span></span><br></pre></td></tr></table></figure></p>
<p><strong>分片和数据共享</strong></p>
<p>可以通过slice方法创建一个新的Buffer和原Buffer共享底层数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = Buffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity; i++)</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>)i);</span><br><span class="line">buffer.position(<span class="number">3</span>);</span><br><span class="line">buffer.limit(<span class="number">10</span>);</span><br><span class="line">Buffer subBuffer = buffer.slice();<span class="comment">//此时subBuffer可见的底层数据只有从3到10的位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subBuffer.capacity; i++)&#123;</span><br><span class="line">    <span class="keyword">byte</span> b = subBuffer.get(i);</span><br><span class="line">    subBuffer.put(b*<span class="number">10</span>);<span class="comment">//只会改变3到10位置上的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>只读缓冲区</strong><br>asReadOnlyBuffer()方法将缓冲区设置为只读,缓冲区不能再进行写入.可以调用isReadOnly()来判断缓冲区是否可写</p>
<p><strong>直接缓冲区&amp;非直接缓冲区</strong><br>allocate方法分配的是非直接缓冲区,allocateDirect方法分配的是直接缓冲区.<br>个人理解:非直接缓冲区的内存是分配在进程空间的,在执行系统的IO,比如写入磁盘,网络的时候,虚拟机指令会调用操作系统API,执行系统调用,将进程空间的缓冲区数据拷贝到内核的缓冲区,然后陷入内核态,由操作系统将缓冲区的数据写入设备.</p>
<p>为直接缓冲区分配的内存是在GC管理的Heap之外的,调用系统IO操作不会有数据拷贝的过程.因为使用直接缓冲区的分配和销毁的开销会比非直接缓冲区大,一般会分配一个较大的的内存,并且该Buffer会长期存在.只有在明确使用直接缓冲区对系统性能提升很大的情况下,才会采用这种分配方案</p>
<p><strong>具体实现类</strong></p>
<ol>
<li>ByteBuffer</li>
<li>基本数据类型Buffer</li>
</ol>
<h4 id="Selector">Selector</h4><p>使用Selector,就可以用一个线程来处理多个通道,这与传统的阻塞式IO有本质的区别.</p>
<p><strong>将Channel注册到Selector</strong><br>注册的时候需要选择感兴趣的时间,Selector支持的事件有:</p>
<ol>
<li>OP_CONNECT</li>
<li>OP_ACCEPT</li>
<li>OP_READ</li>
<li>OP_WRITE<br>对多个事件感兴趣的话可以用与操作将他们连接起来,可以看出来Selector是按位判断注册的事件的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>SelectionKey</strong><br>包含:</p>
<ol>
<li>intrestKeySet</li>
<li>readySet</li>
<li>就绪的Channel</li>
<li>Selector</li>
<li>附加在Channel上的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();<span class="comment">//线程在这里阻塞,直到有注册的操作就绪,返回就绪的Channel数量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存管理和GC">内存管理和GC</h2><h3 id="运行时的数据区">运行时的数据区</h3><blockquote>
<p>根据虚拟机规范划分,只有根据实际应用需求,实现方式选择最优的收集方式才能获取最高的性能</p>
</blockquote>
<ol>
<li>方法区:线程共享,存储加载的类信息,常量池(编译期确定的字面量和符号引用),静态变量,即时编译器编译后的代码</li>
<li>堆:线程共享,存放绝大多数的对象实例</li>
<li>虚拟机栈:保存栈帧</li>
<li>本地方法栈:保存本地方法的栈帧</li>
<li>程序计数器:指向下一条字节码指令</li>
</ol>
<h3 id="HotSpot中的对象">HotSpot中的对象</h3><ol>
<li>对象创建过程:类加载检查-&gt;分配内存(指针碰撞/空闲列表,由GC之后的内存布局决定)-&gt;内存初始化为零值-&gt;设置对象头-&gt;执行<init></init></li>
<li>对象的内存布局:对象头(运行时数据和类型指针,实例数据,对齐填充</li>
<li>对象的访问定位:句柄和直接指针(hotspot采用,引用指向对象的内存地址)<br>GC</li>
</ol>
<h3 id="判断对象存活">判断对象存活</h3><ol>
<li>引用计数:不能解决循环引用问题</li>
<li>可达性分析:从GC ROOT开始,不可达的对象判定为可回收</li>
</ol>
<h3 id="GC算法">GC算法</h3><p>虚拟机实现一般使用分代收集,将堆划分成不同的代,根据每代的对象特点使用不同的GC算法</p>
<ol>
<li>标记-清除:完成所有对象的标记,进行回收.效率不高,内存碎片多</li>
<li>复制:牺牲内存.用来回收新生代,按一定比例划分内存区域,需要分配<strong>担保</strong></li>
<li>标记-整理:多用于对象存活率高的内存区域</li>
</ol>
<h3 id="GC">GC</h3><p>讨论HotSpot中的垃圾收集器,没有最好的GC,每个GC都有自己最适合应用的场景<br>新生代:</p>
<ol>
<li>Serial:复制算法.单线程,GC时必须停止所有用户线程,简单而高效</li>
<li>ParNew:Serial的多线程版本</li>
<li>Parallel Scaveng:使用复制算法,并行多项收集.</li>
</ol>
<p>老年代</p>
<ol>
<li>Serial Old</li>
<li>Parallel Old</li>
<li><strong>CMS</strong>:标记-清除算法.CPU敏感,无法处理浮动垃圾,需要预留一部分空间供并发时的用户线程使用.碎片多.</li>
</ol>
<p>G1收集器<br>将java堆划分成不同的region,在后台维护一个有限列表,有限回收价值最大的region<br>用Remember Set来避免处理<strong>Region之间</strong>的对象引用时进行全堆扫描.</p>
<h3 id="内存分配与回收策略">内存分配与回收策略</h3><p>TLAB(本地线程分配缓冲)&gt;Eden&gt;老年代<br>具体的分配规则取决于GC组合和虚拟机参数</p>
<ol>
<li>优先在Eden中分配,Eden内存不足时触发Minor GC</li>
<li>大对象直接进入老年代(长字符串或大数组之类的).通过设置参数直接在老年代分配内存</li>
<li>长期存活的对象进入老年代.每个对象有一个计数器,每经过一个MinorGC,计数器加1,晋升到老年代的阈值通过虚拟机参数设置</li>
<li>动态年龄判断</li>
</ol>
<p>参考资料:</p>
<ol>
<li>深入理解java虚拟机</li>
<li>java并发编程实战</li>
<li>Java Language Specifications</li>
<li>Java SE7 API Specification</li>
<li>并发编程网</li>
<li>IBM developerWorkers</li>
<li><a href="http://www.raychase.net/1912" target="_blank" rel="external">java.util.concurrent并发包诸类概览</a></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/03/30/ANTLR4学习笔记-语法字典-Grammar-Lexicon/" itemprop="url">
                ANTLR4学习笔记
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-03-30T11:17:15+08:00" content="2015-03-30">
            2015-03-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/ANTLR/" itemprop="url" rel="index">
                  <span itemprop="name">ANTLR</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h2 id="ANTLR4文法文档的基本书写语法,参考ANTLR官方文档,版本V4">ANTLR4文法文档的基本书写语法,参考ANTLR官方文档,版本V4</h2>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/03/30/ANTLR4学习笔记-语法字典-Grammar-Lexicon/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/27/golang-concurrency/" itemprop="url">
                golang-concurrency-学习笔记
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-27T14:24:35+08:00" content="2014-12-27">
            2014-12-27
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/golang/" itemprop="url" rel="index">
                  <span itemprop="name">golang</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h1 id="golang并发编程学习笔记">golang并发编程学习笔记</h1><p>主要涉及channel goroutine 同步<br>参照阅读&lt;&lt; Go并发编程实战 &gt;&gt;</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2014/12/27/golang-concurrency/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/15/golang-RPC/" itemprop="url">
                CMU.Distributed-System.Lab1(RPC)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-15T21:19:19+08:00" content="2014-12-15">
            2014-12-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/golang/" itemprop="url" rel="index">
                  <span itemprop="name">golang</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <p>RPC的一些基本概念和基于golang的简单实现</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2014/12/15/golang-RPC/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/12/CMU-Distributed-System-Lab1/" itemprop="url">
                CMU.Distributed-System.Lab1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-12T20:09:07+08:00" content="2014-12-12">
            2014-12-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/golang/" itemprop="url" rel="index">
                  <span itemprop="name">golang</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h1 id="分布式系统学习笔记">分布式系统学习笔记</h1><h2 id="Lab1-Distributed_Password_Cracker">Lab1.Distributed Password Cracker</h2><h3 id="实验内容:">实验内容:</h3><p><strong>概述</strong><br>实现一个基于互联网环境的分布式”密码”暴力破解应用,”密码”由不可逆的<strong>Hash</strong>函数生成</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2014/12/12/CMU-Distributed-System-Lab1/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/08/Lucene学习笔记-四-并发/" itemprop="url">
                Lucene学习笔记(四)并发
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-08T12:49:35+08:00" content="2014-12-08">
            2014-12-08
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/java/" itemprop="url" rel="index">
                  <span itemprop="name">java</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h1 id="并发,线程安全及锁">并发,线程安全及锁</h1><p>索引文件的并发访问,Reader和Writer的线程安全性,以及Lucene实现前两项内容的锁机制<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2014/12/08/Lucene学习笔记-四-并发/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/07/Lucene学习笔记-三-构建索引/" itemprop="url">
                Lucene学习笔记(三)构建索引
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-07T17:07:25+08:00" content="2014-12-07">
            2014-12-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/java/" itemprop="url" rel="index">
                  <span itemprop="name">java</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <h1 id="构建索引">构建索引</h1><p>一个好的索引构建策略是搜索程序成功的基石<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2014/12/07/Lucene学习笔记-三-构建索引/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/img/images.jpg" alt="Yijun" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Yijun</p>
        </div>
        <p class="site-description motion-element" itemprop="description">coding | java | life</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">標籤</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yijun1171" target="_blank">Github</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yijun</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
